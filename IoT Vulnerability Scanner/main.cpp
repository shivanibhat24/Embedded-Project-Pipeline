#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <fstream>
#include <sstream>
#include <cstring>
#include <algorithm>
#include <regex>
#include <chrono>
#include <thread>
#include <mutex>
#include <future>
#include <set>
#include <filesystem>
#include <cstdlib>
#include <ctime>

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <unistd.h>
#endif

// Platform-specific socket handle and close function
#ifdef _WIN32
typedef SOCKET SocketType;
#define INVALID_SOCKET_VALUE INVALID_SOCKET
#define closeSocket closesocket
#else
typedef int SocketType;
#define INVALID_SOCKET_VALUE -1
#define closeSocket close
#endif

class IoTScanner {
private:
    // Common weak passwords database
    std::vector<std::string> weakPasswords = {
        "admin", "password", "12345", "123456", "default", "admin123",
        "root", "", "pass", "qwerty", "1234", "guest", "00000000"
    };
    
    // Common default credentials (username:password)
    std::map<std::string, std::vector<std::string>> defaultCredentials = {
        {"admin", {"admin", "password", "admin123"}},
        {"root", {"root", "toor", "password"}},
        {"user", {"user", "password", "123456"}},
        {"guest", {"guest", ""}}
    };
    
    // Known vulnerable firmware versions for common IoT devices
    std::map<std::string, std::vector<std::string>> vulnerableFirmware = {
        {"Router", {"v1.0.0", "v1.2.3", "v2.0.1", "v3.1.0"}},
        {"Camera", {"v2.1.5", "v3.0.0", "v1.8.2"}},
        {"SmartLock", {"v1.0", "v2.3", "v3.0"}},
        {"Thermostat", {"v1.1", "v2.0", "v2.5"}}
    };
    
    // Common open ports for IoT devices
    std::vector<int> commonPorts = {
        21, 22, 23, 25, 53, 80, 443, 1883, 8080, 8443, 9000
    };
    
    // Context for scanning
    struct ScanContext {
        std::string ipAddress;
        int timeout = 1000; // in milliseconds
        bool verbose = false;
        std::vector<int> portsToScan;
    };
    
    struct VulnerabilityReport {
        std::string ipAddress;
        std::string deviceType;
        std::string firmwareVersion;
        std::vector<std::string> openPorts;
        std::vector<std::string> vulnerabilities;
        std::vector<std::string> recommendations;
        
        // Add a vulnerability with its recommendation
        void addIssue(const std::string& vulnerability, const std::string& recommendation) {
            vulnerabilities.push_back(vulnerability);
            recommendations.push_back(recommendation);
        }
    };
    
    std::mutex reportMutex;
    std::vector<VulnerabilityReport> reports;
    
    // Initialize socket library (for Windows)
    bool initializeSockets() {
#ifdef _WIN32
        WSADATA wsaData;
        return WSAStartup(MAKEWORD(2, 2), &wsaData) == 0;
#else
        return true;
#endif
    }
    
    // Clean up socket library (for Windows)
    void cleanupSockets() {
#ifdef _WIN32
        WSACleanup();
#endif
    }
    
    // Check if a port is open
    bool isPortOpen(const std::string& ipAddress, int port, int timeoutMs) {
        SocketType sock = socket(AF_INET, SOCK_STREAM, 0);
        if (sock == INVALID_SOCKET_VALUE) {
            return false;
        }
        
        // Set socket timeout
#ifdef _WIN32
        DWORD timeout = timeoutMs;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&timeout, sizeof(timeout));
#else
        struct timeval tv;
        tv.tv_sec = timeoutMs / 1000;
        tv.tv_usec = (timeoutMs % 1000) * 1000;
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&tv, sizeof(tv));
        setsockopt(sock, SOL_SOCKET, SO_SNDTIMEO, (const char*)&tv, sizeof(tv));
#endif
        
        struct sockaddr_in serverAddr;
        memset(&serverAddr, 0, sizeof(serverAddr));
        serverAddr.sin_family = AF_INET;
        serverAddr.sin_port = htons(port);
        
        // Convert IP address
        if (inet_pton(AF_INET, ipAddress.c_str(), &(serverAddr.sin_addr)) <= 0) {
            closeSocket(sock);
            return false;
        }
        
        // Try to connect
        int result = connect(sock, (struct sockaddr*)&serverAddr, sizeof(serverAddr));
        closeSocket(sock);
        
        return result == 0;
    }
    
    // Simulate testing default credentials
    bool testDefaultCredentials(const std::string& ipAddress, int port) {
        // In a real implementation, this would attempt to log in using default credentials
        // For the purposes of this example, we'll just simulate the check
        return (port == 22 || port == 23 || port == 80 || port == 8080);
    }
    
    // Simulate getting firmware version
    std::string getFirmwareVersion(const std::string& ipAddress, int port) {
        // In a real implementation, this would query the device for its firmware version
        // For the purposes of this example, we'll return a simulated version
        std::srand(static_cast<unsigned int>(std::time(nullptr)));
        std::vector<std::string> versions = {"v1.0.0", "v2.1.5", "v3.0.0", "v4.2.1", "v5.0.3"};
        return versions[std::rand() % versions.size()];
    }
    
    // Check if firmware is vulnerable
    bool isVulnerableFirmware(const std::string& deviceType, const std::string& version) {
        if (vulnerableFirmware.find(deviceType) != vulnerableFirmware.end()) {
            const auto& versions = vulnerableFirmware[deviceType];
            return std::find(versions.begin(), versions.end(), version) != versions.end();
        }
        return false;
    }
    
    // Determine device type based on open ports (simplified)
    std::string guessDeviceType(const std::vector<int>& openPorts) {
        if (std::find(openPorts.begin(), openPorts.end(), 80) != openPorts.end() &&
            std::find(openPorts.begin(), openPorts.end(), 443) != openPorts.end() &&
            std::find(openPorts.begin(), openPorts.end(), 22) != openPorts.end()) {
            return "Router";
        } else if (std::find(openPorts.begin(), openPorts.end(), 554) != openPorts.end()) {
            return "Camera";
        } else if (std::find(openPorts.begin(), openPorts.end(), 1883) != openPorts.end()) {
            return "SmartHome";
        } else if (std::find(openPorts.begin(), openPorts.end(), 8080) != openPorts.end() &&
                  std::find(openPorts.begin(), openPorts.end(), 8443) != openPorts.end()) {
            return "Thermostat";
        }
        return "Unknown";
    }
    
    // Scan a single device
    VulnerabilityReport scanDevice(const ScanContext& context) {
        VulnerabilityReport report;
        report.ipAddress = context.ipAddress;
        
        if (context.verbose) {
            std::cout << "Scanning device at " << context.ipAddress << "..." << std::endl;
        }
        
        // Find open ports
        std::vector<int> openPorts;
        for (int port : context.portsToScan) {
            if (isPortOpen(context.ipAddress, port, context.timeout)) {
                openPorts.push_back(port);
                report.openPorts.push_back(std::to_string(port));
                
                if (context.verbose) {
                    std::cout << "  Port " << port << " is open" << std::endl;
                }
            }
        }
        
        // Guess device type based on open ports
        report.deviceType = guessDeviceType(openPorts);
        
        if (context.verbose) {
            std::cout << "  Detected device type: " << report.deviceType << std::endl;
        }
        
        // Check for Telnet and SSH
        if (std::find(openPorts.begin(), openPorts.end(), 23) != openPorts.end()) {
            report.addIssue(
                "Telnet (port 23) is open, which is insecure and transmits data in plaintext",
                "Disable Telnet and use SSH (port 22) instead with strong authentication"
            );
        }
        
        // Check for default credentials
        for (int port : openPorts) {
            if (testDefaultCredentials(context.ipAddress, port)) {
                report.addIssue(
                    "Potential default credentials detected on port " + std::to_string(port),
                    "Change default username and passwords to strong, unique credentials"
                );
                break;
            }
        }
        
        // Check firmware version for known vulnerabilities
        if (!report.deviceType.empty() && report.deviceType != "Unknown") {
            report.firmwareVersion = getFirmwareVersion(context.ipAddress, openPorts[0]);
            
            if (context.verbose) {
                std::cout << "  Detected firmware version: " << report.firmwareVersion << std::endl;
            }
            
            if (isVulnerableFirmware(report.deviceType, report.firmwareVersion)) {
                report.addIssue(
                    "Device running vulnerable firmware version " + report.firmwareVersion,
                    "Update firmware to the latest version from the manufacturer's website"
                );
            }
        }
        
        // Check for unnecessary open ports
        if (openPorts.size() > 3) {
            report.addIssue(
                "Multiple services exposed (" + std::to_string(openPorts.size()) + " open ports)",
                "Close unnecessary ports and services that are not required for operation"
            );
        }
        
        // Check for unencrypted web interface
        if (std::find(openPorts.begin(), openPorts.end(), 80) != openPorts.end() &&
            std::find(openPorts.begin(), openPorts.end(), 443) == openPorts.end()) {
            report.addIssue(
                "Web interface available over unencrypted HTTP (port 80)",
                "Configure the device to use HTTPS (port 443) with a valid certificate"
            );
        }
        
        return report;
    }

public:
    IoTScanner() {
        if (!initializeSockets()) {
            std::cerr << "Failed to initialize network library" << std::endl;
            exit(1);
        }
    }
    
    ~IoTScanner() {
        cleanupSockets();
    }
    
    // Scan a range of IP addresses
    void scanNetwork(const std::string& baseIp, int startRange, int endRange, bool verbose = false) {
        reports.clear();
        std::vector<std::future<void>> futures;
        
        // Extract the base IP (e.g., "192.168.1" from "192.168.1.1")
        std::string ipBase = baseIp.substr(0, baseIp.find_last_of('.') + 1);
        
        for (int i = startRange; i <= endRange; i++) {
            std::string ip = ipBase + std::to_string(i);
            
            futures.push_back(std::async(std::launch::async, [this, ip, verbose]() {
                ScanContext context;
                context.ipAddress = ip;
                context.verbose = verbose;
                context.portsToScan = commonPorts;
                
                VulnerabilityReport deviceReport = scanDevice(context);
                
                // Only add the report if vulnerabilities were found
                if (!deviceReport.vulnerabilities.empty()) {
                    std::lock_guard<std::mutex> lock(reportMutex);
                    reports.push_back(deviceReport);
                }
            }));
        }
        
        // Wait for all scans to complete
        for (auto& future : futures) {
            future.wait();
        }
    }
    
    // Scan specific IP addresses
    void scanSpecificDevices(const std::vector<std::string>& ipAddresses, bool verbose = false) {
        reports.clear();
        std::vector<std::future<void>> futures;
        
        for (const auto& ip : ipAddresses) {
            futures.push_back(std::async(std::launch::async, [this, ip, verbose]() {
                ScanContext context;
                context.ipAddress = ip;
                context.verbose = verbose;
                context.portsToScan = commonPorts;
                
                VulnerabilityReport deviceReport = scanDevice(context);
                
                std::lock_guard<std::mutex> lock(reportMutex);
                reports.push_back(deviceReport);
            }));
        }
        
        // Wait for all scans to complete
        for (auto& future : futures) {
            future.wait();
        }
    }
    
    // Generate a report of the vulnerabilities found
    void generateReport(const std::string& outputFile = "") {
        std::ostream* output = &std::cout;
        std::ofstream fileStream;
        
        if (!outputFile.empty()) {
            fileStream.open(outputFile);
            if (!fileStream.is_open()) {
                std::cerr << "Failed to open output file: " << outputFile << std::endl;
                return;
            }
            output = &fileStream;
        }
        
        *output << "===============================================" << std::endl;
        *output << "        IoT VULNERABILITY SCAN REPORT         " << std::endl;
        *output << "===============================================" << std::endl;
        *output << "Scan completed at: " << getCurrentDateTime() << std::endl;
        *output << "Devices scanned: " << reports.size() << std::endl;
        *output << "Vulnerabilities found: " << getTotalVulnerabilities() << std::endl;
        *output << "===============================================" << std::endl << std::endl;
        
        for (const auto& report : reports) {
            *output << "Device IP: " << report.ipAddress << std::endl;
            *output << "Device Type: " << (report.deviceType.empty() ? "Unknown" : report.deviceType) << std::endl;
            
            if (!report.firmwareVersion.empty()) {
                *output << "Firmware Version: " << report.firmwareVersion << std::endl;
            }
            
            *output << "Open Ports: " << join(report.openPorts, ", ") << std::endl;
            *output << std::endl;
            
            *output << "VULNERABILITIES:" << std::endl;
            *output << "----------------" << std::endl;
            
            for (size_t i = 0; i < report.vulnerabilities.size(); i++) {
                *output << "- " << report.vulnerabilities[i] << std::endl;
                *output << "  Recommendation: " << report.recommendations[i] << std::endl << std::endl;
            }
            
            *output << "===============================================" << std::endl << std::endl;
        }
        
        *output << "GENERAL RECOMMENDATIONS:" << std::endl;
        *output << "------------------------" << std::endl;
        *output << "1. Change default credentials on all IoT devices" << std::endl;
        *output << "2. Keep firmware updated to the latest version" << std::endl;
        *output << "3. Disable unnecessary services and close unused ports" << std::endl;
        *output << "4. Use strong encryption for all communications" << std::endl;
        *output << "5. Place IoT devices on a separate network segment" << std::endl;
        *output << "6. Implement network-level monitoring and protection" << std::endl;
        *output << "7. Regularly scan for vulnerabilities" << std::endl;
        
        if (fileStream.is_open()) {
            std::cout << "Report saved to: " << outputFile << std::endl;
            fileStream.close();
        }
    }
    
private:
    // Get the current date and time as a string
    std::string getCurrentDateTime() {
        auto now = std::chrono::system_clock::now();
        std::time_t now_time = std::chrono::system_clock::to_time_t(now);
        
        std::stringstream ss;
        ss << std::ctime(&now_time);
        std::string datetime = ss.str();
        
        // Remove the newline character that ctime adds
        if (!datetime.empty() && datetime[datetime.length() - 1] == '\n') {
            datetime.erase(datetime.length() - 1);
        }
        
        return datetime;
    }
    
    // Join vector elements with a delimiter
    std::string join(const std::vector<std::string>& elements, const std::string& delimiter) {
        std::stringstream ss;
        for (size_t i = 0; i < elements.size(); i++) {
            ss << elements[i];
            if (i < elements.size() - 1) {
                ss << delimiter;
            }
        }
        return ss.str();
    }
    
    // Get the total number of vulnerabilities found
    int getTotalVulnerabilities() {
        int total = 0;
        for (const auto& report : reports) {
            total += report.vulnerabilities.size();
        }
        return total;
    }
};

void displayHelp() {
    std::cout << "IoT Vulnerability Scanner" << std::endl;
    std::cout << "Usage:" << std::endl;
    std::cout << "  iot_scanner [options]" << std::endl;
    std::cout << std::endl;
    std::cout << "Options:" << std::endl;
    std::cout << "  -h, --help                 Display this help message" << std::endl;
    std::cout << "  -r, --range <base> <start> <end>  Scan a range of IP addresses" << std::endl;
    std::cout << "      Example: -r 192.168.1 1 10" << std::endl;
    std::cout << "  -i, --ip <address>         Scan a specific IP address" << std::endl;
    std::cout << "      Can be used multiple times to scan multiple addresses" << std::endl;
    std::cout << "  -o, --output <file>        Write report to specified file" << std::endl;
    std::cout << "  -v, --verbose              Enable verbose output" << std::endl;
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        displayHelp();
        return 1;
    }
    
    std::string outputFile;
    bool verbose = false;
    std::vector<std::string> specificIps;
    std::string baseIp;
    int startRange = 0, endRange = 0;
    bool rangeMode = false;
    
    // Parse command line arguments
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];
        
        if (arg == "-h" || arg == "--help") {
            displayHelp();
            return 0;
        } else if (arg == "-v" || arg == "--verbose") {
            verbose = true;
        } else if (arg == "-o" || arg == "--output") {
            if (i + 1 < argc) {
                outputFile = argv[++i];
            } else {
                std::cerr << "Error: Output file path missing" << std::endl;
                return 1;
            }
        } else if (arg == "-i" || arg == "--ip") {
            if (i + 1 < argc) {
                specificIps.push_back(argv[++i]);
            } else {
                std::cerr << "Error: IP address missing" << std::endl;
                return 1;
            }
        } else if (arg == "-r" || arg == "--range") {
            if (i + 3 < argc) {
                baseIp = argv[++i];
                startRange = std::stoi(argv[++i]);
                endRange = std::stoi(argv[++i]);
                rangeMode = true;
            } else {
                std::cerr << "Error: Range parameters missing" << std::endl;
                return 1;
            }
        }
    }
    
    IoTScanner scanner;
    
    std::cout << "IoT Vulnerability Scanner" << std::endl;
    std::cout << "=======================" << std::endl << std::endl;
    
    try {
        if (rangeMode) {
            std::cout << "Scanning IP range " << baseIp << "." << startRange << " to " 
                      << baseIp << "." << endRange << "..." << std::endl;
            scanner.scanNetwork(baseIp, startRange, endRange, verbose);
        } else if (!specificIps.empty()) {
            std::cout << "Scanning " << specificIps.size() << " specific IP address(es)..." << std::endl;
            scanner.scanSpecificDevices(specificIps, verbose);
        } else {
            std::cerr << "Error: No IP addresses specified for scanning" << std::endl;
            displayHelp();
            return 1;
        }
        
        std::cout << "Scan completed, generating report..." << std::endl;
        scanner.generateReport(outputFile);
        
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}
